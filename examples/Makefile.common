# BSP430 examples shared Makefile.common
#
# This file is in the public domain.
#
# BSP430 applications can significantly reduce the size of
# application-specific Makefiles by defining BSP430_ROOT, perhaps PLATFORM,
# and SRC, then including this file.  Some variables documented in this file
# enable specific features.

# BSP430_ROOT: Path to root of a BSP430 installation.  This is used to set
# paths for platform files.
ifndef BSP430_ROOT
$(error Must specify BSP430_ROOT)
endif # BSP430_ROOT

# WITH_CCS: Indicate that Code Composer Studio is installed and the TI
# compiler used in it should be preferred.  Unless defined to 1, assumes CCS
# will not be used.
# WARNING: This is a stub.  CCS is not supported by BSP430.
# NOTE: Within the source, the toolchain is identified as the TI compiler,
# not CCS.
WITH_CCS ?= 0
ifneq (0,$(WITH_CCS))
WITH_GCC ?= 0
endif # WITH_GCC

# WITH_GCC: Unless defined to 0, assume that GCC will be used, and
# define options suitable for building with it.
WITH_GCC ?= 1

ifneq (0,$(WITH_GCC))
CROSS_COMPILE ?= msp430-
CC=$(CROSS_COMPILE)gcc
LD=$(CROSS_COMPILE)ld
AR=$(CROSS_COMPILE)ar
SIZE=$(CROSS_COMPILE)size
endif # WITH_GCC
ifneq (0,$(WITH_CCS))
CCS_INSTALL_ROOT ?= /usr/local/ccs/ccsv5

# CCS_BASE_ROOT is the name used in CCS Eclipse project files for the
# code-generator--independent files such as MCU-specific headers
CCS_BASE_ROOT ?= $(CCS_INSTALL_ROOT)/ccs_base

# CG_TOOL_ROOT is the name used in CCS Eclipse project files for the
# compiler toolchain root
ifndef CG_TOOL_ROOT
CG_TOOL_ROOT := $(shell ls -d $(CCS_INSTALL_ROOT)/tools/compiler/msp430_*)
endif # CG_TOOL_ROOT

CC=cl430
OBJ_EXT=.obj
CFLAGS = --abi=eabi --relaxed_ansi
CPPFLAGS = --include_path="$(CCS_BASE_ROOT)/msp430/include"
CPPFLAGS += --include_path="$(CG_TOOL_ROOT)/include"

# This one allows the MCU-specific linker file to include more generic
# linker files.
LDFLAGS = -i"$(CCS_BASE_ROOT)/msp430/include"
# This one find -llibc.a (implicit
LDFLAGS += -i"$(CG_TOOL_ROOT)/lib"
# This one initializes data at runtime from tables stored in ROM.
# Note that global variables without initializers are not zeroed
# as is required by the C standard.  No workaround.
LDFLAGS += --rom_model
endif # WITH_CCS

# TEST_PLATFORMS: Space-separated list of platforms to use for testing a
# given application.  Defaults to all known platforms.
TEST_PLATFORMS ?= \
    em430 \
    exp430f5438 \
    exp430f5529 \
    exp430fg4618 \
    exp430fr5739 \
    exp430g2 \
    rf2500t \
    surf \
    trxeb \
    wolverine

# TEST_PLATFORMS_EXCLUDE: Space-separated list of platforms not to use for
# testing a given application.  These platforms are removed from
# TEST_PLATFORMS in the emit-test-platforms goal.
TEST_PLATFORMS_EXCLUDE ?=

# PLATFORM: Standard nomenclature for a particular board with
# particular features.  If defined, other settings such as the MCU and
# how to flash the application might be read from a common file.
ifdef PLATFORM
-include $(BSP430_ROOT)/src/platform/$(PLATFORM)/Makefile.common
endif # PLATFORM

# TARGET_*FLAGS: Target-specific flags controlling MCU selection,
# memory model, etc.

TARGET_CPPFLAGS ?=
TARGET_CFLAGS ?=
TARGET_LDFLAGS ?=

# MCU: The specific microcontroller for which the application is to be
# built.  Must be defined; a suitable default may be provided by the
# platform Makefile.common.
ifndef MCU
$(error No MCU identified)
endif # MCU

ifneq (0,$(WITH_GCC))
TARGET_CFLAGS += -mmcu=$(MCU)
TARGET_LDFLAGS += -mmcu=$(MCU)

# MEMORY_MODEL: Level of 20-bit support, assuming this is a CPUX MCU.
ifdef MEMORY_MODEL
TARGET_CFLAGS += -mmemory-model=$(MEMORY_MODEL)
TARGET_LDFLAGS += -mmemory-model=$(MEMORY_MODEL)
endif # MEMORY_MODEL
endif # WITH_GCC

ifneq (0,$(WITH_CCS))
# Add the define for the target MCU
TARGET_CPPFLAGS += -D__$(shell echo $(MCU)|tr '[a-z]' '[A-Z]')__
endif # WITH_CCS

# OPT_CFLAGS: CFLAGS related to optimization and debugging.  The
# default enables debugging and optimizes for size, and puts each
# function and data object in its own section so it can be discarded
# at link time if not needed.  Also review OPT_LDFLAGS.
ifneq (0,$(WITH_CCS))
OPT_CFLAGS ?= -o -mf=0
endif # WITH_CCS
ifneq (0,$(WITH_GCC))
OPT_CFLAGS ?= -ggdb -Os -ffunction-sections -fdata-sections
endif # WITH_GCC

# OPT_LDFLAGS: LDFLAGS related to optimization and debugging.  THe
# default value enables removal of unreferenced sections during
# non-relocatable link.
ifneq (0,$(WITH_GCC))
OPT_LDFLAGS ?= -Wl,-gc-sections
endif # WITH_GCC

# WARN_CFLAGS: CFLAGS that control warnings
ifneq (0,$(WITH_GCC))
WARN_CFLAGS ?= -Wall -Wno-main
endif # WITH_GCC
ifneq (0,$(WITH_CCS))
# Suppress various TI compiler warnings.  Use -pden to add diagnostic number
# to output.
# 10374 : Interrupt vector "PERIPHERAL" does not have an interrupt handler routine
WARN_CFLAGS ?= --diag_suppress=10374
endif # WITH_CCS

# WITH_WARN_ERROR: If not set to zero, adds -Werror which causes all
# warnings to be treated as errors.
WITH_WARN_ERROR ?= 1
ifneq (0,$(WITH_WARN_ERROR))
ifneq (0,$(WITH_GCC))
WARN_CFLAGS += -Werror
endif # WITH_GCC
endif # WITH_WARN_ERROR

# External capabilities

# EMBTEXTF_ROOT: If defined use http://pabigot.github.com/embtextf/ to
# supply enhanced text formatting capabilities for the console.
ifdef EMBTEXTF_ROOT
CPPFLAGS += -DBSP430_CONSOLE_USE_EMBTEXTF -I"$(EMBTEXTF_ROOT)/include"
AUX_LDLIBS += $(EMBTEXTF_ROOT)/lib/libembtextf.a
endif # EMBTEXTF_ROOT

CPPFLAGS += $(TARGET_CPPFLAGS)

CFLAGS += $(WARN_CFLAGS)
CFLAGS += $(OPT_CFLAGS)
CFLAGS += $(TARGET_CFLAGS)

LDFLAGS += $(OPT_LDFLAGS)
LDFLAGS += $(TARGET_LDFLAGS)

# Assume the application-specific bsp430_config.h is same directory as the
# Makefile.

CPPFLAGS += -I.

# GNU Make function to convert text to upper case (assuming a POSIX shell
# environment)
uc=$(shell echo $(1) | tr '[a-z]' '[A-Z]')

# Add BSP430 support, if requested
ifdef PLATFORM
CPPFLAGS += -DBSP430_PLATFORM_$(call uc,$(PLATFORM))
endif # PLATFORM

ifdef BSP430_ROOT
CPPFLAGS += -I$(BSP430_ROOT)/include
endif # BSP430_ROOT

# Append any extra flags pre-defined in the Makefile (AUX_*) or passed
# on the make command line (EXT_*).
CPPFLAGS += $(AUX_CPPFLAGS) $(EXT_CPPFLAGS)
CFLAGS += $(AUX_CFLAGS) $(EXT_CFLAGS)
LDFLAGS += $(AUX_LDFLAGS) $(EXT_LDFLAGS)
LDLIBS += $(AUX_LDLIBS) $(EXT_LDLIBS)

# Since the same BSP430 capability (e.g., timer or serial) may be needed for
# multiple purposes, the SRC variable cannot simply accrue each dependency
# as it occurs, since doing so would result in the same source file being
# listed multiple times.  We avoid that by passing accruing BSP430
# capabilities as "modules".
#
# Sources from the BSP430 library are identified by a module tag, being the
# relative path inclusive of the implementation file base name within the
# BSP430 src directory.  For example, periph/usci results in
# $(BSP430_ROOT)/src/periph/usci.c being added as a source dependency.
#
# The set of modules is defined by the application-specific Makefile, by
# assigning them to the MODULES variable.  Platform-independence is
# supported by pre-defining core capabilities in named module variables like
# MODULES_UPTIME.  The listed modules are sorted, made unique, and added to
# the SRC dependency prior to building the application.
#
# The infrastructure places nothing in MODULES itself.  You'll want at least
# $(MODULES_PLATFORM), which should provides the platform and clocks code.

# MODULES_TIMER: The identifiers for basic timer functionality.  Primarily
# exists for consistency in naming.
MODULES_TIMER = periph/timer

# MODULES_UPTIME: The timer in combination with the uptime facility.
MODULES_UPTIME = $(MODULES_TIMER) utility/uptime

# MODULES_CLOCK: Platform specific, the module supplying the implementation
# of the clock interface.

# MODULES_PLATFORM_SERIAL: Platform specific, the module supplying the
# platform peripheral implementations supporting serial interface.

# MODULES_SERIAL: The platform-specific serial modules in combination with
# the common serial model for generic serial communication.
MODULES_SERIAL ?= $(MODULES_PLATFORM_SERIAL) serial

# MODULES_LED: Platform specific, the module supplying the implementation of
# the LED interface.  If not set by the platform, this is assumed to be the
# common implementation in the utility suite.  If the platform module
# supplies the LEDs, then name it explicitly for this function.
MODULES_LED ?= utility/led

# MODULES_CONSOLE: The serial module in combination with the console
# facility.
MODULES_CONSOLE = $(MODULES_SERIAL) utility/console

# MODULES_EUI64: Support for EUI-64 values.  Application-specific provided
# by application; platform specific may be defaulted by the platform
# Makefile.common; otherwise use the shared implementation.
MODULES_EUI64 ?= utility/eui64

# MODULES_M25P: Support for platform M25P serial flash memory.  Only defined
# on platforms that have such a chip wired in and supported using
# #configBSP430_PLATFORM_M25P.
MODULES_M25P ?=

# MODULES_PLATFORM: The platform-specific platform module, together
# with the clock and LED modules and anything the platform thinks is
# important.  The combination is non-orthogonal, but convenient.
MODULES_PLATFORM ?= platform/$(PLATFORM)/platform $(MODULES_CLOCK) $(MODULES_LED) $(MODULES_PLATFORM_AUX)

# Add all selected modules to the SRC, eliminating any duplicates

# This places dependencies and object files in the common directories.  It
# makes builds across platforms and between applications confusing.
# undefine VPATH
#SRC += $(patsubst %,$(BSP430_ROOT)/src/%.c,$(sort $(MODULES)))

# This places all dependencies and object files in the app directory, but
# would break if the same file basename is used for different capabilities.
# Doesn't happen for now; let's see how it works.
ifdef PLATFORM
VPATH += $(BSP430_ROOT)/src/platform/$(PLATFORM)
endif # PLATFORM
VPATH += $(BSP430_ROOT)/src/utility
VPATH += $(BSP430_ROOT)/src/periph
VPATH += $(BSP430_ROOT)/src
SRC += $(addsuffix .c,$(notdir $(sort $(MODULES))))

# This places dependencies and object files in subdirectories of the app
# directory, but would require somebody to create those subdirectories
#VPATH=$(BSP430_ROOT)/src
#SRC += $(addsuffix .c,$(sort $(MODULES)))

# Normal compilers use .o for object files.  TI's uses .obj, and defines
# OBJ_EXT above.
OBJ_EXT ?= .o

# Object files derive from C source files and preprocessed assembly files
OBJ += $(SRC:.c=$(OBJ_EXT)) $(SRC_S:.S=$(OBJ_EXT))

# Dependency files derive from anything that was preprocessed.  I'd like
# these stuffed in a hidden subdirectory, haven't worked that one yet.
# Also see http://locklessinc.com/articles/makefile_tricks/
DEP += $(SRC:.c=.d) $(SRC_S:.S=.d)

# MSPDEBUG: Path to the mspdebug application (http://mspdebug.sourceforge.net/)
MSPDEBUG ?= mspdebug

# MSPDEBUG_PROG: Command used by mspdebug to write an image into flash.
# "prog" for most MCUs, but "load" for FRAM.
MSPDEBUG_PROG ?= prog

# MSPDEBUG_OPTIONS: Options influencing mspdebug, such as the USB or
# tty device to be used.
MSPDEBUG_OPTIONS ?=

# MSPDEBUG_DRIVER: Driver used by mspdebug to interact with the target
# device.  This variable should include any MSPDEBUG options specific
# to the driver, e.g. that the uif driver is to use JTAG.
MSPDEBUG_DRIVER ?= -j uif

# WITH_MSPDEBUG: Unless defined to 0, assume that the image will be
# downloaded to the board using mspdebug.  If this is zero, an install
# rule must be provided externally.
WITH_MSPDEBUG ?= 1

# BSP430_INHIBIT_MAKE_RULES: Define to a nonzero value to exclude the
# Make rules while leaving all the variable declarations in place.
# This allows the BSP430 build infrastructure to provide toolchain
# and platform declarations to an external build infrastructure
# like that for Contiki, which wants to provide its own rules.
BSP430_INHIBIT_MAKE_RULES ?= 0
ifeq (0,$(BSP430_INHIBIT_MAKE_RULES))

ifneq (0,$(WITH_GCC))
# Use GCC to generate dependency files
%.d: %.c
	set -e; $(RM) $@; \
	 $(CC) -MM -MT$*.o $(CPPFLAGS) $(CFLAGS) $< > $@.$$$$; \
	 sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
	 $(RM) $@.$$$$

# Object file derived from assembler source including preprocessor
%.o: %.S
	$(CC) $(CPPFLAGS) $(CFLAGS) -c -o $@ $<

# Interleaved source/object-code/asm listing
%.lst: %.c
	$(CC) $(CPPFLAGS) $(CFLAGS) -ggdb -Wa,-ahdlns=$@ -c $<
CLEAN += $(SRC:.c=.lst)
endif # WITH_GCC

ifneq (0,$(WITH_CCS))
# Rule for CCS compiler which insists on placing output in foo.obj
%.obj: %.c
	$(CC) -c $(CFLAGS) $(CPPFLAGS) $<
REALCLEAN_OBJ ?= *.obj
endif # WITH_CCS

# On realclean remove all object files even if they aren't in $(OBJ)
# (e.g., when PLATFORM is not set).  Note the pattern may be
# toolchain-dependent.
REALCLEAN_OBJ ?= *.o
REALCLEAN += $(REALCLEAN_OBJ)

# AOUT: The name of the application image.
AOUT ?= app.elf
$(AOUT): $(OBJ)
ifneq (0,$(WITH_CCS))
	$(CC) $(CFLAGS) -z $(LDFLAGS) -o $@ $(OBJ) $(LDLIBS) $(CCS_BASE_ROOT)/msp430/include/lnk_$(MCU).cmd
else # WITH_CCS
	$(CC) -o $@ $(CFLAGS) $(LDFLAGS) $(OBJ) $(LDLIBS)
endif # WITH_CCS
ifneq (0,$(WITH_GCC))
	$(SIZE) $@
endif # WITH_GCC

# CLEAN: Additional files to be removed on make clean
clean:
	-$(RM) $(OBJ) $(CLEAN)

# REALCLEAN: Additional files to be removed on make realclean
realclean: clean
	-$(RM) $(AOUT) $(DEP) $(REALCLEAN) *.d *.o

ifneq (0,$(WITH_MSPDEBUG))
install: $(AOUT)
	$(MSPDEBUG) $(MSPDEBUG_OPTIONS) $(MSPDEBUG_DRIVER) '$(MSPDEBUG_PROG) $(AOUT)'
endif # WITH_MSPDEBUG

# Include dependencies unless we're cleaning
ifeq ($(filter-out realclean clean emit-test-platforms test-platforms, $(MAKECMDGOALS)),$(MAKECMDGOALS))
-include $(DEP)
endif # make [real]clean

TEST_PLATFORMS_=$(filter-out $(TEST_PLATFORMS_EXCLUDE), $(TEST_PLATFORMS))

.PHONY: emit-test-platforms
emit-test-platforms:
	@echo $(TEST_PLATFORMS_)

# Goal to rebuild all example programs on all supported platforms.
# Drive this with:
# for tc in $(find examples -name Makefile | egrep -v '/fragpool/') ; do make -C $(dirname ${tc}) test-platforms || break ; done
.PHONY: test-platforms
test-platforms:
	@$(MAKE) realclean >/dev/null 2>&1 ;        \
	for p in $(TEST_PLATFORMS_) ; do            \
	     echo "=== Building for $${p}" ;        \
	     ( ( $(MAKE) PLATFORM=$${p} app.elf )   \
               > $${p}.log 2>&1                     \
               && tail -3 $${p}.log                 \
	       && $(MAKE) realclean >/dev/null 2>&1 \
               && rm -f $${p}.log )                 \
             || break ;                             \
	done ;                                      \
	if test -f $${p}.log ; then                 \
           echo "FAILED on $${p}:" ;                \
	   cat $${p}.log ;                          \
	fi

endif # BSP430_INHIBIT_MAKE_RULES

# Local Variables:
# mode:makefile
# End:
